# -*- coding: utf-8 -*-
"""Ecuación de Helmholtz.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10KPGjAjQkbfEXgsNQVwIdRD36kmrVEXL

# Ecuación de Helmholtz, proyecto final.

La frontera está dada por:

![WhatsApp Image 2024-08-29 at 20.48.11_670e138b.jpg](data:image/jpeg;base64,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RQAUUUUAFFFFABRXlf7RWreJtH8E20nhXXJ9Nv7/AFOz0m1MAIY3V1cRwxOWB4SPe8hXo+1QeMg5Ph34jatr3iL4obfFVxFb6PfR6Zo8NtpL6g8K2scS3U628CmSUtcTMhAz/quB8poA9qrB1/xroXh3U9P0O8knn1TVVlks7G1gaaaWOIAySbVGFRdy5ZiBllAJLAHyn/hOfF3/AEUTxT/4Z/WP/jVZ+jzapcftVeE9U1S8urqG++Gt9Hb3FzpsuntLOmowtL/o8oDxNsaMlSM4welAHuXh3xHovizR4Ne8P3y3djc7gkgVlIZWKurKwDIysrKysAQQQQCK0q8X/ZVW8/4QjxRdXCt9nu/HfiSeyPZoDqEoDL6gsHIr2igAooooAKKKKACiiigAori/jN48uPhh8K/FHj6z08X11ommy3NvbnOJZsYjVsdF3lc+2a89+HeueKrD40J4M8Q/ES81QW3hW0l1a2nWLy59bumllzEFTMKpBbSkRghdrKcFjkgHu1FFFABRRXAfGbxNY+FvCN/q2oeLE0iDTtNv9TlginEV3eJBAzbYmyGADFSxXn7oyATkA7+ivMvgbZ+J4/D9tqHjLx7qGu67d6Ppkmq2cyxiGzvGhMkjIFUbS4dcqPlARTjLEn02gAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAp6to+ka9YvpmuaXaahZyMrNBdQrLGWVgynawIyGAIPYgGq+jeFvDPhxpn8P8Ah3TNMa5x5xs7SOEyY6btgGce9alFABWVrvhfw74mW3XXtHtb02jmS3eWP54WI2sUf7yEqSDgjIJB4NatFAFbTdN0/R7CDS9JsLeysrWMRQW9vEsccSDoqqoAUD0FWaKKACiiigAooooAKKKKAK+oafY6tYz6ZqllBeWd1G0M9vPGJI5UYYZWVgQwI4INZOleA/BOh6p/bejeEtIstR8n7ObuCzjSYx8naXA3Hqep7mt6igAooooAKx9d8H+E/FEtvP4k8M6VqslosiQNe2ccxjV8b1XeDgNtXI6HaPQVsUUAUdH0PRfD1kum6DpNpp1qp3CG1hWNM8DOFAGeB+VXqKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//2Q==)

Con a=b=1.
"""

# Librerias.
import math as mt
import numpy as np
import matplotlib.pyplot as plt
import scipy as sc
import sympy as sp
from mpl_toolkits.mplot3d import Axes3D

# Discretización.
N=40
M=N
w=-2 # Valor w.
X=np.linspace(0,1,N+1)
Y=np.linspace(0,1,M+1)
k=(1-0)/M
h=(1-0)/N
l=k/h

# Función de frontera.
def g(x): return np.sin(3*mt.pi*x)

# Matriz -A.
A=np.zeros((N*M,N*M))
for i in range(N*M): # Diagonal.
  A[i,i]=4-w*(h**2)
for i in range(N*M-1): # Subdiagonales.
  A[i,i+1]=-1
  A[i+1,i]=-1
for i in range(N,N*M): # Superdiagonal.
  A[i,i-N]=-1
for i in range(N*M-N): # Superdiagonal.
  A[i,i+N]=-1
for i in range(N,N*M,N):
  A[i,i-1]=0
  A[i-1,i]=0

# Matriz -b.
b=np.zeros((N*M,1))
for i in range(N*M-N,N*M):
  b[i,0]=-g(X[i-(N*M-N)])

"""## Solución real.

Está dada por:
"""

def l_n(n): return np.pi*n # Lambda_n
def g_n(n): return np.sqrt((l_n(n)**2)-w) # Gamma_n
def f(x,n): return 2*np.sin(3*np.pi*x)*np.sin(l_n(n)*x) # Función integrable.

# Renovamos la discretización.
X=np.linspace(0,1,N+1)
Y=np.linspace(0,1,M+1)
# Calculamos las parejas (x,y).
Val=[(c, p) for p in Y[1::] for c in X[1::]]
X=np.array([i[0] for i in Val])
Y=np.array([i[1] for i in Val])

# Calculamos la solución analítica.
sol=np.zeros((N*M))
for i in range(1,150): # La sumatoria aproximada hasta n=150.
  a_n=sc.integrate.quad(f,0,1,args=(i,)) # El termino a_n.
  t_n=(a_n[0]/np.sinh(g_n(i)))*np.sinh(g_n(i)*Y)*np.sin(l_n(i)*X) # El término n-ésimo de la sumatoria.
  t_n=np.array(t_n)
  sol=sol+t_n # Sumamos.

# Graficar la solución analítica:
def graficar_analitica():
  fig = plt.figure()
  ax = plt.axes(projection='3d')
  surface = ax.plot_trisurf(X,Y,sol, cmap='viridis')
  ax.set_xlabel('X')
  ax.set_ylabel('Y')
  ax.set_zlabel("U")
  ax.title.set_text(f"Solución Analítica N: {N}")
  plt.show()
graficar_analitica()

"""## Solución aproximada por CGM."""

# Inicializar las variables

xi = np.ones((N*N,1))  # Vector inicial xi con N*N elementos, vector unidimensional
ri = b - np.dot(A, xi)  # Residuo inicial
di = ri.copy()  # Dirección inicial, misma dimensión que ri
error = 10**(-4)  # Tolerancia del error

for _ in range(1000):  # Número máximo de iteraciones

    qk = np.dot(A, di)  # Aplicar la matriz A a di
    alphai = np.dot(ri.T, ri) / np.dot(di.T, qk)

    xi_new = xi + alphai * di  # Actualizar xi.

    ri_new = ri - alphai * qk  # Actualizar ri.

    # Verificar convergencia.
    if np.linalg.norm(ri_new) < error: # Verificar el error.
        print(f"Convergencia alcanzada: {_} iteraciones.") # Muestra las iteraciones.
        break

    betai = np.dot(ri_new.T, ri_new) / np.dot(ri.T, ri)

    di = ri_new + betai * di  # Actualizar di.

    # Actualizar xi y ri para la siguiente iteración
    xi = xi_new
    ri = ri_new

def graficar_CGM():
  global xi
  fig = plt.figure()
  ax = plt.axes(projection='3d')
  xi=xi.reshape(N*N)
  surface = ax.plot_trisurf(X,Y,-xi, cmap='viridis')
  ax.set_xlabel('X')
  ax.set_ylabel('Y')
  ax.set_zlabel("x1")
  ax.title.set_text(f"Solución Aproximada N: {N}")
  plt.show()
graficar_CGM()

"""## Estudio del error:"""

# Grafica del error.
error=np.array(sol-xi) # Calcular el error.
# Graficar.
fig = plt.figure()
ax = plt.axes(projection='3d')
surface = ax.plot_trisurf(X,Y,error)
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel("x1")
ax.title.set_text(f"Solución Aproximada N: {N}")
plt.show()

# Error máximo.
error=np.linalg.norm(sol+xi,np.inf)
error

"""## Solución aproximada con PCGM.

Jacobi Preconditioner: M será la diagonal de A.
"""

Mat = np.diag(np.diag(A))
M_inv = sc.linalg.inv(Mat)  # Calcula el inverso de M

# Inicializar las variables
xi_PCGM = np.ones((N*N,1))  # Vector inicial xi con N*N elementos, vector unidimensional
ri = b - np.dot(A, xi_PCGM)  # Residuo inicial
zi = M_inv.dot(ri)  # Aplicar el precondicionador al residuo
di = zi.copy()  # Dirección inicial
error = 10**(-4)  # Tolerancia del error

# Iteración del método PCGM
for _ in range(1000):  # Número máximo de iteraciones
    qk = np.dot(A, di)
    alphai = np.dot(ri.T, zi) / np.dot(di.T, qk)

    xi_new = xi_PCGM + alphai * di
    ri_new = ri - alphai * qk

    if np.linalg.norm(ri_new) < error:
        print(f"Convergencia alcanzada en la iteración: {_}")
        break

    zi_new = M_inv.dot(ri_new)  # Aplicar el precondicionador al nuevo residuo
    betai = np.dot(ri_new.T, zi_new) / np.dot(ri.T, zi)

    di = zi_new + betai * di

    # Actualizar xi, ri y zi para la siguiente iteración
    xi_PCGM = xi_new
    ri = ri_new
    zi = zi_new

def graficar_PCGM():
  global xi_PCGM
  fig = plt.figure()
  ax = plt.axes(projection='3d')
  xi_PCGM=xi_PCGM.reshape(N*N)
  surface = ax.plot_trisurf(X,Y,-xi_PCGM, cmap='viridis')
  ax.set_xlabel('X')
  ax.set_ylabel('Y')
  ax.set_zlabel("x1")
  ax.title.set_text(f"Solución Aproximada con PCGM N: {N}")
  plt.show()
graficar_PCGM()

"""Precondicionador de Gauss-Seidel: Este divide la matriz A en una matriz triangular inferior L, una matriz diagonal D, y una matriz triangular superior U.

El precondicionador se define como: M=(D+L) donde D es la parte diagonal de A y L es la parte triangular inferior.
"""

# Precondicionador de Gauss-Seidel
D = np.diag(np.diag(A))
L = np.tril(A) - D
M = D + L
M_inv = np.linalg.inv(M)  # Inverso del precondicionador de Gauss-Seidel

# Inicializar las variables
xi = np.ones((N*N,1))  # Vector inicial xi con N*N elementos, vector unidimensional
ri = b - np.dot(A, xi)  # Residuo inicial
zi = np.dot(M_inv, ri)  # Aplicar el precondicionador al residuo
di = zi.copy()  # Dirección inicial
error = 10**(-4)  # Tolerancia del error

# Iteración del método PCGM
for _ in range(1000):  # Número máximo de iteraciones
    qk = np.dot(A, di)
    alphai = np.dot(ri.T, zi) / np.dot(di.T, qk)

    xi_new = xi + alphai * di
    ri_new = ri - alphai * qk

    if np.linalg.norm(ri_new) < error:
        print(f"Convergencia alcanzada en la iteración {_}")
        break

    zi_new = np.dot(M_inv, ri_new)  # Aplicar el precondicionador al nuevo residuo
    betai = np.dot(ri_new.T, zi_new) / np.dot(ri.T, zi)

    di = zi_new + betai * di

    # Actualizar xi, ri y zi para la siguiente iteración
    xi = xi_new
    ri = ri_new
    zi = zi_new
xi_PCGM=xi.copy()

graficar_PCGM()

"""Precondicionador Incomplete Cholesky (IC). El precondicionador IC se construye descomponiendo la matriz A de tal manera que $A≈LL^T$ donde L es una matriz triangular inferior y $L^T$ es su transpuesta. Esta aproximación se utiliza en lugar de la matriz completa para ahorrar memoria y cálculos."""

from scipy.sparse.linalg import spilu
from scipy.sparse import csc_matrix

# Convertir A a una matriz dispersa para la factorización IC
A_sparse = csc_matrix(A)

# Precondicionador Incomplete Cholesky
ilu = spilu(A_sparse)  # Incomplete LU factorization
M_inv = lambda x: ilu.solve(x)  # Precondicionador aplicando la factorización ILU

# Inicializar las variables
xi = np.ones((N*N,1))  # Vector inicial xi con N*N elementos, vector unidimensional
ri = b - np.dot(A, xi)  # Residuo inicial
zi = M_inv(ri)  # Aplicar el precondicionador al residuo
di = zi.copy()  # Dirección inicial
error = 10**(-2)  # Tolerancia del error

# Iteración del método PCGM
for _ in range(10000):  # Número máximo de iteraciones
    qk = np.dot(A, di)
    alphai = np.dot(ri.T, zi) / np.dot(di.T, qk)

    xi_new = xi + alphai * di
    ri_new = ri - alphai * qk

    if np.linalg.norm(ri_new) < error:
        print(f"Convergencia alcanzada en la iteración {_}")
        break

    zi_new = M_inv(ri_new)  # Aplicar el precondicionador al nuevo residuo
    betai = np.dot(ri_new.T, zi_new) / np.dot(ri.T, zi)

    di = zi_new + betai * di

    # Actualizar xi, ri y zi para la siguiente iteración
    xi = xi_new
    ri = ri_new
    zi = zi_new

xi_PCGM=xi.copy()

graficar_PCGM()